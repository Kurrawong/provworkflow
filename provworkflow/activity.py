from __future__ import annotations

from datetime import datetime
from typing import List, Optional

from pydantic import Field
from rdflib import Graph, Literal
from rdflib.namespace import PROV, RDF, XSD

from .agent import Agent
from .entity import Entity
from .prov_reporter import ProvReporter, PROVWF


class Activity(ProvReporter):
    """prov:Activity

    :param uri: A URI you assign to the Activity instance. If None, a UUID-based URI will be created,
    defaults to None
    :type uri: Union[URIRef, str], optional

    :param label: A text label you assign, defaults to None
    :type label: str, optional

    :param named_graph_uri: A Named Graph URI you assign
    :type named_graph_uri: Union[URIRef, str], optional

    :param used: A list of Entities used (prov:used) by this Block
    :type used: List[Block], optional

    :param generated: A list of Entities used (prov:generated) by this Block
    :type generated: List[Block], optional

    :param was_associated_with: An Agent that ran this Block (prov:wasAssociatedWith), may or may not be the same as
        the one associated with the Workflow
    :type was_associated_with: Agent, optional

    :param informed: Another Activity that this Activity triggered the creation of
    :type informed: Activity, optional

    :param was_informed_by: Another Activity that triggered the creation of this Activity
    :type was_informed_by: Activity, optional
    """

    used: List[Entity] = Field(
        default_factory=list, description="List of entities used by this activity"
    )
    generated: List[Entity] = Field(
        default_factory=list, description="List of entities generated by this activity"
    )
    was_associated_with: Optional[Agent] = Field(
        default=None, description="Agent associated with this activity"
    )
    informed: List[Activity] = Field(
        default_factory=list, description="List of activities informed by this activity"
    )
    started_at_time: str = Field(
        default_factory=lambda: datetime.now()
        .astimezone()
        .strftime("%Y-%m-%dT%H:%M:%S%z"),
        description="Time the activity started",
    )
    ended_at_time: Optional[str] = Field(
        default=None, description="Time the activity ended"
    )

    def prov_to_graph(self, g: Optional[Graph] = None) -> Graph:
        g = super().prov_to_graph(g)

        # Add in type
        g.add((self.uri, RDF.type, PROV.Activity))
        g.remove((self.uri, RDF.type, PROVWF.ProvReporter))

        # Add startedAtTime
        g.add(
            (
                self.uri,
                PROV.startedAtTime,
                Literal(
                    self.started_at_time,
                    datatype=XSD.dateTimeStamp,
                ),
            )
        )

        # Add used entities
        for e in self.used:
            e.prov_to_graph(g)
            g.add((self.uri, PROV.used, e.uri))

        # Add generated entities
        for e in self.generated:
            e.prov_to_graph(g)
            g.add((self.uri, PROV.generated, e.uri))

        # Add associated agent
        if self.was_associated_with is not None:
            self.was_associated_with.prov_to_graph(g)
            g.add((self.uri, PROV.wasAssociatedWith, self.was_associated_with.uri))

        # Add informed activities
        for i in self.informed:
            i.prov_to_graph(g)
            g.add((i.uri, PROV.wasInformedBy, self.uri))

        # Set and add endedAtTime if not already set
        if self.ended_at_time is None:
            self.ended_at_time = (
                datetime.now().astimezone().strftime("%Y-%m-%dT%H:%M:%S%z")
            )

        g.add(
            (
                self.uri,
                PROV.endedAtTime,
                Literal(
                    self.ended_at_time,
                    datatype=XSD.dateTimeStamp,
                ),
            )
        )

        return g
